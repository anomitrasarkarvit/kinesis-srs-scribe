import jsPDF from 'jspdf';

export class ExportService {
  static async exportAsMarkdown(content: string, filename: string = 'srs-document'): Promise<void> {
    try {
      const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `${filename}.md`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Failed to export Markdown:', error);
      throw new Error('Failed to export as Markdown file');
    }
  }

  static async exportAsPDF(content: string, filename: string = 'srs-document'): Promise<void> {
    try {
      // Create a new PDF document
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4',
      });

      // Set up PDF styling
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const margin = 20;
      const lineHeight = 6;
      const maxWidth = pageWidth - (margin * 2);

      let yPosition = margin;

      // Helper function to add a new page if needed
      const checkPageBreak = (requiredSpace: number = lineHeight) => {
        if (yPosition + requiredSpace > pageHeight - margin) {
          pdf.addPage();
          yPosition = margin;
        }
      };

      // Helper function to process and add text
      const addText = (text: string, fontSize: number = 10, fontStyle: string = 'normal') => {
        pdf.setFontSize(fontSize);
        pdf.setFont('helvetica', fontStyle);
        
        const lines = pdf.splitTextToSize(text, maxWidth);
        
        for (const line of lines) {
          checkPageBreak();
          pdf.text(line, margin, yPosition);
          yPosition += lineHeight;
        }
      };

      // Parse markdown and convert to PDF
      const lines = content.split('\n');
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        if (!line) {
          yPosition += lineHeight * 0.5; // Add spacing for empty lines
          continue;
        }

        // Handle headers
        if (line.startsWith('# ')) {
          checkPageBreak(lineHeight * 2);
          yPosition += lineHeight;
          addText(line.substring(2), 18, 'bold');
          yPosition += lineHeight * 0.5;
        }
        else if (line.startsWith('## ')) {
          checkPageBreak(lineHeight * 1.5);
          yPosition += lineHeight * 0.5;
          addText(line.substring(3), 14, 'bold');
          yPosition += lineHeight * 0.25;
        }
        else if (line.startsWith('### ')) {
          checkPageBreak(lineHeight * 1.5);
          yPosition += lineHeight * 0.25;
          addText(line.substring(4), 12, 'bold');
          yPosition += lineHeight * 0.25;
        }
        // Handle lists
        else if (line.match(/^[-*+]\s/)) {
          const listText = 'â€¢ ' + line.substring(2);
          addText(listText, 10);
        }
        else if (line.match(/^\d+\.\s/)) {
          addText(line, 10);
        }
        // Handle bold text
        else if (line.includes('**')) {
          let processedLine = line;
          let isBold = false;
          let currentText = '';
          
          for (let j = 0; j < processedLine.length; j++) {
            if (processedLine.substring(j, j + 2) === '**') {
              if (currentText) {
                addText(currentText, 10, isBold ? 'bold' : 'normal');
                currentText = '';
              }
              isBold = !isBold;
              j++; // Skip the second *
            } else {
              currentText += processedLine[j];
            }
          }
          
          if (currentText) {
            addText(currentText, 10, isBold ? 'bold' : 'normal');
          }
        }
        // Handle horizontal rules
        else if (line.match(/^---+$/)) {
          checkPageBreak(lineHeight);
          yPosition += lineHeight * 0.5;
          pdf.setDrawColor(0, 0, 0);
          pdf.line(margin, yPosition, pageWidth - margin, yPosition);
          yPosition += lineHeight * 0.5;
        }
        // Regular text
        else {
          addText(line, 10);
        }
      }

      // Add footer with timestamp
      const totalPages = pdf.internal.pages.length - 1; // Subtract 1 because pages array includes a null first element
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'normal');
        pdf.text(
          `Generated by Kinesis SRS Builder - ${new Date().toLocaleDateString()}`,
          margin,
          pageHeight - 10
        );
        pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, pageHeight - 10);
      }

      // Save the PDF
      pdf.save(`${filename}.pdf`);
    } catch (error) {
      console.error('Failed to export PDF:', error);
      throw new Error('Failed to export as PDF file');
    }
  }

  static generateFilename(baseFilename: string = 'srs-document'): string {
    const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
    return `${baseFilename}-${timestamp}`;
  }
}

export const exportService = ExportService;